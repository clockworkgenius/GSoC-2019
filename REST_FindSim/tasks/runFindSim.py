import subprocess
import re

from third_party.FindSim.findSim import *

# Atfer running the task, return this to front-end/client
class Task_result():

    def __init__(self):
        self.score = 0.0
        self.time = 0.0
        self.figure = ""
        # When something is wrong,
        # front-end/client can get info from this
        self.error = ""

    def set_score(self, _score):
        self.score = _score

    def set_time(self, _time):
        self.time = _time

    def set_figure(self, _figure):
        self.figure = _figure

    def set_error(self, _error):
        self.error = _error

    def has_error(self):
        return not self.error == ''

# Parse the output generated by interface_FindSim.py
# If the output pattern is changed, change the code here
# for adjustment.
def parseFindSimOutput(output = str, error = str):
    tResult = Task_result()

    errormsg = ""

    # Get result from stdout output strings
    # Check if there is error or exception
    if error != ""\
    or re.search('time', output, re.I) == None\
    or re.search('score', output, re.I) == None:
        # Error happens, parse output to get the error messege
        if re.search('error',output, re.I) != None:
            p1 = re.compile(r'[a-zA-Z0-9.]*error.*', re.I)
            errors = p1.findall(output)
            errormsg += errors[-1] + '  '
        if re.search('exception',output, re.I) != None:
            p2 = re.compile(r'[a-zA-Z0-9]*exception.*', re.I)
            errors = p2.findall(output)
            errormsg += errors[-1] + '  '
        if re.search('error',error, re.I) != None:
            p3 = re.compile(r'[a-zA-Z0-9.]*error.*', re.I)
            errors = p3.findall(error)
            errormsg += errors[-1] + '  '
        if re.search('exception',error, re.I) != None:
            p4 = re.compile(r'[a-zA-Z0-9]*exception.*', re.I)
            errors = p4.findall(error)
            errormsg += errors[-1] + '  '
        if errormsg == "":
            errormsg += output+error
        tResult.set_error(errormsg)
        return tResult

    # No error, parse the getoutput
    f_loc = output.find('[Figure]')
    res_output = output[0:f_loc]
    res_figure = output[f_loc+len('[Figure]'):]
    outs = res_output.split(' ')

    tResult.set_score(outs[2])
    tResult.set_time(outs[6])
    tResult.set_figure(res_figure)

    return tResult

def decodeBytes(content):
    if content == None:
        return ""
    else:
        return content.decode()

def runTask( script, modelFile , dumpFname = "", paramFname = "", optimizeElec=True, silent = False, scaleParam=[], settleTime = 0, settleDict = {} ):
    tResult = Task_result()

    # Validation of .tsv file and modle file
    fs = script.split('.')
    if len(fs) < 2 or fs[-1] != 'tsv':
        tResult.set_error('Invalid script file type.')
    fs = []
    fs = modelFile.split('.')
    if len(fs) < 2 or (fs[-1] != 'g' and fs[-1] != 'xml'):
        tResult.set_error('Invalid model file type.')

    if tResult.error:
        return tResult

    # Generate command line
    # This .py code print all we need into stdout
    command_FindSim = 'python third_party/interface_FindSim.py '+script+' -m '+modelFile
    # TODO(Chen): add other arguments into command line
    '''
    if dumpFname:
    if paramFname:
    if not optimizeElec:
    if silent:
    if scaleParam:
    if settleTime:
    if settleDict:
    '''

    # Run FindSim via subprocess
    # output = subprocess.getoutput(command_FindSim)
    p = subprocess.Popen(command_FindSim,shell=True,stdout=subprocess.PIPE,stderr=subprocess.STDOUT)
    output_info, error_info = p.communicate()

    #print(type(output_info))
    #print(type(error_info))
    p.wait()

    # Parse output
    tResult = parseFindSimOutput(decodeBytes(output_info),decodeBytes(error_info))

    return tResult
